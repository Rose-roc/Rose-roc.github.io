---
title: question_one
date: 2021-03-02 11:20:27
tags: 
 - android
categories: 刷题
thumbnail: /img/05.png
---



### 今日份刷题

#### ARP

地址解析协议，即ARP（Address Resolution Protocol），是根据[IP地址](https://baike.baidu.com/item/IP地址)获取[物理地址](https://baike.baidu.com/item/物理地址/2129)的一个[TCP/IP协议](https://baike.baidu.com/item/TCP%2FIP协议)。[主机](https://baike.baidu.com/item/主机/455151)发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个[ARP欺骗](https://baike.baidu.com/item/ARP欺骗)。

#### TCP三握四挥，为什么三握四挥

![image-20210306104538212](C:\Users\radish\AppData\Roaming\Typora\typora-user-images\image-20210306104538212.png)

![image-20210306104613185](C:\Users\radish\AppData\Roaming\Typora\typora-user-images\image-20210306104613185.png)

　注：处于TIME-WAIT状态的A必须等待2MSL时间后，才会进入CLOSED状态。MSL（Maximum Segment Lifetime）最长报文段寿命HTTP请求 响应报文

#### HTTP请求 响应报文

HTTP请求报文由四个部分组成：请求行、请求头部、空行、请求数据。

请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成

HTTP响应报文也由三部分组成：响应行、响应头、响应体

响应行一般由协议版本、状态码及其描述组成

//常见状态码：

100：这个状态码是告诉客户端应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应继续发送求请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果

200：这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请求的最终结果

202：表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定

204：服务器成功处理了请求，但没有返回任何实体内容 ，可能会返回新的头部元信息

301：重定向，客户端请求的网页已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端链接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果

404：请求失败，客户端请求的资源没有找到或者是不存在

500：服务器遇到未知的错误，导致无法完成客户端当前的请求。

503：服务器由于临时的服务器过载或者是维护，无法解决当前的请求

#### HTTP的方法和作用

GET方法

发送一个请求来取得服务器上的某一资源

POST方法

向URL指定的资源提交数据或附加新的数据

PUT方法

跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有

HEAD方法

只请求页面的首部

DELETE方法

删除服务器上的某资源

OPTIONS方法

它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息

TRACE方法

TRACE方法被用于激发一个远程的，应用层的请求消息回路

CONNECT方法

把请求连接转换到透明的TCP/IP通道

#### HTTP首部有什么重要的字段&原因

请求头（Request）：
Accept：text/html application/xml 告诉服务器客户端浏览器这边可以出里什么数据；
Accept-Encodeing：gzip 告诉服务器我能支持什么样的压缩格式
accept-language：告诉服务器浏览器支持的语言
Cache-control：告诉服务器是否缓存
Connection:keep-alive 告诉服务器当前保持活跃（与服务器处于链接状态）
Host：远程服务器的域名
User-agent：客户端的一些信息，浏览器信息 版本
referer：当前页面上一个页面地址。一般用于服务器判断是否为同一个域名下的请求

返回头（response-header）：
cache-control:private/no-cache; 私有的不需要缓存/no-cache也不需要缓存
connection:keep-live; 服务器同意保持连接
content-Enconding：gzip；除去头的剩余部分压缩返回格式
content-length:内容长度
content-type：text/css;返回内容支持格式
Date： 时间
server：ngnix 服务器类型
set-Cookie:服务器向客户端设置cookie 第一次访问服务器会下发cookie当作身份认证信息，第二次访问服务器再把cookie送给服务器，可以当作认证信息
last-modified: 时间戳 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。Last-Modified也可用setDateHeader方法来设置。
expires 告诉浏览器把回送的资源缓存多长时间 -1或0则是不缓存
etag:版本专有的加密指纹。（有的网站不用，并非必须）优先检查etag再检查last-modified的时间戳。向服务器请求带if-none-match,服务器判断是否过期未过期返回304，过期返回200

#### 进程和线程的区别

进程：进程是并发执行程序在执行过程中资源分配和管理的基本单位（资源分配的最小单位）。进程可以理解为一个应用程序的执行过程，应用程序一旦执行，就是一个进程。每个进程都有自己独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。

线程：程序执行的最小单位。

1. 地址空间： 同一进程的所有线程共享本进程的地址空间，而不同的进程之间的地址空间是独立的。

2. 资源拥有： 同一进程的所有线程共享本进程的资源，如内存，CPU，IO等。进程之间的资源是独立的，无法共享。

3. 执行过程：每一个进程可以说就是一个可执行的应用程序，每一个独立的进程都有一个程序执行的入口，顺序执行序列。但是线程不能够独立执行，必须依存在应用程序中，由程序的多线程控制机制进行控制。

4. 健壮性： 因为同一进程的所以线程共享此线程的资源，因此当一个线程发生崩溃时，此进程也会发生崩溃。 但是各个进程之间的资源是独立的，因此当一个进程崩溃时，不会影响其他进程。因此进程比线程健壮。

线程执行开销小，但不利于资源的管理与保护。

进程的执行开销大，但可以进行资源的管理与保护。进程可以跨机器前移。

#### 进程间的通信

管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

#### 进程同步

进程同步的四种方法

1、临界区（Critical Section）:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。

优点：保证在某一时刻只有一个线程能访问数据的简便办法

缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。

2、互斥量（Mutex）:为协调共同对一个共享资源的单独访问而设计的。

互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。

优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。

缺点：①互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。

②通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。

3、信号量（Semaphore）:为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。

优点：适用于对Socket（套接字）程序中线程的同步。（例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。）

缺点：①信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点；

②信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；

③核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。

4、事件（Event）: 用来通知线程有一些事件已发生，从而启动后继任务的开始。

优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。

总结：

①临界区不是内核对象，只能用于进程内部的线程同步，是用户方式的同步。互斥、信号量是内核对象可以用于不同进程之间的线程同步（跨进程同步）。
②互斥其实是信号量的一种特殊形式。互斥可以保证在某一时刻只有一个线程可以拥有临界资源。信号量可以保证在某一时刻有指定数目的线程可以拥有临界资源。

#### 链表和数组的区别 从内存方面说说区别

数组的特点

- 在内存中，数组是一块连续的区域。 
- 数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。 
- 插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。
- 随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。
- 并且不利于扩展，数组定义的空间不够时要重新定义数组。

链表的特点

- 在内存中可以存在任何地方，不要求连续。 
- 每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。
- 增加数据和删除数据很容易。 
- 查找数据时效率低，因为不具有随机访问性，所以访问某个位置的数据都要从第一个数据开始访问，然后根据第一个数据保存的下一个数据的地址找到第二个数据，以此类推。
- 不指定大小，扩展方便。链表大小不用定义，数据随意增删。